#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Autor: G Camillo
# Last revision:20230701

"""

Program (Python Script) that creates a UDP socket server and implements a simple protocol for receiving simple information in the form of JWT.

Main goal: laboratory used by limited group of students (UFSC-DEC7557) to send information about their members.

Resources used: UDP sockets; JWT tokens (JWS); signing and checking JWS


Payload of REQUEST
{
"group": "JAVALI" | "PINHAO" | "BISSAU" | "NONAME" | "SOQUETINHO",
"seq_number": 1|2|3|4,
"seq_max": 2-4,
"matricula": xxxxxxx,
}

Payload of RESPONSE: the response contains info about the request and the next information:
  - next_number  indicates a ACK to the information provided in request. How is calculated:
     case 1: next_number = seq_number + 1
     case 2: next_number = 0   in the case all the data are received
{
  # hashing (SHA256) of request payload
  "id_request": f12010c0ec208fae7b0031714839f7d639d921c6a6e73ad97a1aab4cc21ba43e,
  "next_number": 2,
  "otp_number": 3205,    #  OTP random number generated during create of Response
  "otp_timestamp": 1687046022, #  OTP timestamp generated during create of Response
}

Protocol definition about the next_number: the generation will account the
max number from two sources:
a) from request; or
b) from data definition in groups_num_members

20230629: in this version, the option (b) will be used

"""


# Set debugging messages - flag to printout log messages in screen
printout_in_screen: bool = False


import datetime
import hashlib   # For create ID with hash of request payload
import jwt
import os
import pathlib
import random
import shutil
import sys
import traceback

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from jwt import InvalidSignatureError
from socket import socket, AF_INET, SOCK_DGRAM


groups = ('JAVALI',
          'PINHAO',
          'BISSAU',
          'NONAME',
          'SOQUETINHO',
          'HEARTBEAT')


groups_num_members = {'JAVALI': 3,
                      'PINHAO': 3,
                      'BISSAU': 3,
                      'NONAME': 4,
                      'SOQUETINHO': 3,
                      'HEARTBEAT': 1 }  # This group is for testing the server

groups_last_num_received = {'JAVALI': 0,
                            'PINHAO': 0,
                            'BISSAU': 0,
                            'NONAME': 0,
                            'SOQUETINHO': 0,
                            'HEARTBEAT': 0}

public_keys = {}
secret_key = None

# Directories that contains the keys
dir_of_priv_keys = "keys_priv"
file_secret_key = "keys_priv/key_secret_for_hmac.txt"
dir_of_pub_keys = "keys_pub"

# Logs contect: basic error handling
log_file = "log-for-udpserver-jwt.txt"

# Logs content: timestamp:ip:port:REQUEST_CONTENT_CODED
log_file_conn = 'dec7557-log-connection_and_request.txt'

# Logs content: timestamp:group_name:PAYLOADS:OK | NOTOK (signature verification)
log_file_content = 'dec7557-log-group_and_payload.txt'

# Logs content for responses: timestamp:group_name:PAYLOAD|JWS
log_file_responses = 'dec7557-log-group_and_responses.txt'

# Logs content: timestamp:grupo_name:SUCESS:all tokens sended (but without confirmation)
log_file_sucess = 'dec7557-log-sucess.txt'

log_response_pay = "dec7557-response-payloads.txt"
log_response_jwt = "dec7557-response-JWT.txt"


def print_log(message):
    if printout_in_screen:
        print(f"{message}")
    else:
        pass

def read_public_keys(base_dir):
    """ Read the public keys from directory specified by global variable: dir_of_pub_keys
         The key data is writen in the dic public_keys
         Two types of publics keys:
         - PEM format created by cyberchef.org or by OpenSSL
         - SSH format generated by ssh-keygen
    """
    print_log("\n -- Reading Public Keys --- \n")
    # We will use the base dir from parameter supplied in command line
    path = pathlib.Path(base_dir + "/" + dir_of_pub_keys)
    #  path = pathlib.Path(os.getcwd() + "/" + dir_of_pub_keys)

    # Read the public key in PEM format generated by cyberchef and openssl
    for f in path.rglob("*.pem"):
        with open(f, 'r') as file:
            file_content = file.read()
            print_log(f"-- Public Key: {path}\n")
            print_log(file_content)
            # filename_full = f.name -> filename = filename_full.strip('.')[0]
            # The final path component, without its suffix:
            filename = f.stem
            if filename.upper() in groups:
                public_keys[filename.upper()] = file_content

    # Read the public key in SSH format
    for f in path.rglob("*.ssh"):
        with open(f, 'r') as file:
            file_content = file.read()
            print_log(f"-- Public Key: {path}\n")
            print_log(file_content)
            filename = f.stem
            if filename.upper() in groups:
                key_pub = serialization.load_ssh_public_key(file_content.encode())
                if isinstance(key_pub, rsa.RSAPublicKey):
                    public_keys[filename.upper()] = key_pub


def read_secret_key(base_dir) -> str:
    """
    Obs.: the secret_key is initialized with None
    :param base_dir: the base directory: /keys_priv/key_secret_for_hmac.txt The file contains de passphrase in
                    bytes without new line.
    :return: the secret key (passphrase) in BYTES (encoded) without new line.
    """

    print_log("\n -- Reading the Secret Key --- \n")
    # We will use the base dir from parameter supplied in command line
    path = pathlib.Path(base_dir + "/" + file_secret_key)
    #  path = pathlib.Path(os.getcwd() + "/" + file_secret_key)

    # The secret_key will be read as BYTES: the encode is not necessary
    with open(path, 'rb') as file:
        secret_key = file.read()
        print_log(f"[read_secret_key] secret_key: {secret_key}\n")
    return secret_key


def write_log(log_filename: str, line: str) -> str:
    try:
        # The log_filename NEED now contain the full path
        # log_filename = os.path.join(os.getcwd(), filename)
        with open(log_filename, 'a') as f:
            # f.write(time.ctime() + line)
            # f.write(datetime.datetime.now().astimezone().replace(microsecond=0).isoformat() + line)
            # Local to ISO 8601 with TimeZone information (Python 3) - UTC to ISO 8601:
            f.write(datetime.datetime.utcnow().isoformat() + line)
    except OSError:
        print_log(f"File {log_filename} can not be found")


# TODO: need GENERATE EXCEPTION
def handle_request(request):
    try: # JWS: Decode and NOT check for signature
        jwt_dec = jwt.decode(request, options={"verify_signature": False})
        g_name = jwt_dec['group']
        g_name = str(g_name.upper())
        print_log(f"[Handle Request] JWT decoded - type: {type(jwt_dec)}\n")
        print_log(f"[Handle Request] JWT decoded - content: {jwt_dec}\n")
        write_log(log_file_conn, f":{g_name}:{jwt_dec}:OK\n")
    except DecodeError:
        write_log(log_file_content, ":ERROR: Failed to decode: {e}\n")
        return None

    # If we can decode, then we will use the information of group name to obtain the public key
    try:  #  JWS: Decode and CHECK SIGNATURE
        request_payload = jwt.decode(request, key=public_keys[g_name], algorithms=["RS256"], options={"verify_signature": True})
    except InvalidTokenError as e:
        write_log(log_file_content, f":{g_name}:{jwt_dec}:NOTOK:ERROR:invalid token:{e}\n")
        return None
    except InvalidTokenError as e:
        write_log(log_file_content, f":{g_name}:{jwt_dec}:NOTOK:ERROR:failed to decode:{e}\n")
        return None
    except InvalidSignatureError as e:
        write_log(log_file_content, f":{g_name}:{jwt_dec}:NOTOK:ERROR:failed signature checked:{e}\n")
        return None
    except InvalidAlgorithmError as e:
        write_log(log_file_content, f":{g_name}:{jwt_dec}:NOTOK:ERROR:error in algorithm:{e}\n")
        return None
    except InvalidKeyError as e:
        write_log(log_file_content, f":{g_name}:{jwt_dec}:NOTOK:ERROR:problem in the keys:{e}\n")
        return None
    else:
        print_log(f"[Handle Request] JWT decoded and verified: {request_payload}\n")
        write_log(log_file_content, f":{g_name}:{request_payload}:Signature OK\n")
        return request_payload


# TODO: need GENERATE EXCEPTION
# This function generates the payload of response. It will be signed by HMAC.
def generate_payload_for_response(request_payload, next_number):
    payload_for_response = {}
    print_log(f"[Generate Payload for Response] Payload of Request: {request_payload}\n")
    timestamp = datetime.datetime.now().astimezone().isoformat()
    if request_payload['group'] in groups:
        request_in_str = str(request_payload)
        payload_for_response['id_request'] = hashlib.sha256(request_in_str.encode("utf-8")).hexdigest()
        payload_for_response['next_number'] = next_number
        payload_for_response['otp_number']  = str(random.randint(0, 20000))
        payload_for_response['otp_timestamp']  = int(datetime.datetime.utcnow().timestamp())
        print_log(f"[Generate Payload for Response] Payload for Response: {payload_for_response}")
        write_log(log_file_responses, f":{request_payload['group']}:{payload_for_response}\n")
        return payload_for_response

# TODO: need GENERATE EXCEPTION
def generate_token_jws(payload, secret_key) -> str:
    """
    :param payload: JSON data contained the response
    :param secret_key: the passphrase in BYTES (encoded)
    :return: JWT encoded and SIGNED with HMAC (with secret_key) | None in Exception
    """
    print_log(f"[Generate Token JWS for Response] Payload: {payload}\n")
    try:
        jwt_encoded = jwt.encode(payload=payload, key=secret_key, algorithm="HS256")
        print_log(f"[Generate Token JWS for Response] JWS: {jwt_encoded}\n")
        return jwt_encoded
    except Exception:
        return None

# This function defines the protocol and states of the server.
def what_next_number(g_name, seq_number, seq_max):
    """
    :param g_name: the name of the group: it was checked from the content of the request
    :param seq_number: the number of the message (sequential number of group element)
    :param seq_max: the max number of elements in group, and the max number of messages
    :return: the next_number that this server expects from the client

    Obs.: It will be used the total number os members from groups_num_members, but it can be extracted from:
          max_number_elements_in_group = jwt_dec['seq_max']
          # g_num_received = request_payload['seq_number']
    """
    # Case 0: restart the protocol
    if seq_number == 0:
        groups_last_num_received[g_name] = 0
        return (True, 1)

    # Case 1: client ressent last information
    if seq_number == groups_last_num_received[g_name]:
        next_number = seq_number + 1
        # Case 3: arrived in final state: CHECK with max number contained in request
        # if groups_num_members[g_name] == seq_number:
        # if groups_num_members[g_name] == seq_max:
        if seq_number == seq_max:
            next_number = 0
            #  Max number will be retrieved from request.
            # groups_last_num_received[g_name] = groups_num_members[g_name]
            groups_last_num_received[g_name] = seq_max
        return (True, next_number)

    # Case 2: client received OK and sending next number
    if seq_number == groups_last_num_received[g_name] + 1:
        next_number = seq_number + 1
        groups_last_num_received[g_name] = groups_last_num_received[g_name] + 1
        # Case 3: arrived in final state: CHECK with max number contained in request
        # if groups_num_members[g_name] == seq_number:
        # if groups_num_members[g_name] == seq_max:
        if seq_number == seq_max:
            next_number = 0
            groups_last_num_received[g_name] = groups_num_members[g_name]
        return (True, next_number)

    return (False, 0)


def udp_server(server_addr, server_port, buffer):
    try:
        server_sock = socket(AF_INET, SOCK_DGRAM)
    except OSError as e:
        server_sock = None
    try:
        server_sock.bind((server_addr, server_port))
    except OSError as e:
        server_sock.close()
        server_sock = None

    if server_sock is None:
        trace = traceback.format_exc()
        print_log(f"ERROR in socket creation: {trace}")
        open('trace.log', 'a').write(trace)
        sys.exit(1)

    print(f'[*] Listening on {server_addr}:{server_port}')

    try:
        while True:
            request_raw, client_addr = server_sock.recvfrom(buffer)
            print_log(f'[*] Accepted connection from {client_addr[0]}:{client_addr[1]}\n')
            print_log(f'[*] Received: {request_raw} - Received decoded: {request_raw.decode("utf-8")}\n')
            request = request_raw.decode('utf-8')
            write_log(log_file_conn , f':{client_addr[0]}:{client_addr[1]}:{request}\n')

            # Function to decode and extract PAYLOAD from JWS: decode and check signature
            request_payload = handle_request(request)
            print_log(f"[udp_server] Payload of Request: {request_payload}\n")

            if request_payload is None:
                print_log(f"[udp_server] ERROR in handle request: {request_payload}\n")
                write_log(log_file_content, f":{request_payload}\n")
                continue  # Do nothing if the udp payload not contains valid data (protocol)
            else:
                group = request_payload['group']
                seq_number = request_payload['seq_number']
                # 20230629: the value of seq_max will be retrieved from the data definition
                #         in this code.
                seq_max = groups_num_members[group]
                #         No more from the user payload
                # seq_max = request_payload['seq_max']
                respond, next_number = what_next_number(group.upper(), int(seq_number), int(seq_max))
                print_log(f"[udp_server] respond:{respond} and next_number:{next_number}\n")
                # TODO use None
                if respond:
                    payload_for_response = generate_payload_for_response(request_payload, next_number)
                    write_log(log_file_responses, f":{group}:{payload_for_response}\n")
                    print_log(f"[udp_server] group:{group} payload:{payload_for_response}\n")
                    # write_log(log_file_content, f":{g_name}:{request_payload}:NOT_VERIFIED:max number of members reached")
                    # write_log(log_file_sucess, f"{g_name}:SUCESS:all tokens received and checked")
                    response = generate_token_jws(payload_for_response, secret_key)
                    if response is None:
                        continue
                    else:
                        write_log(log_file_responses, f":{group}:{response}\n")
                        print_log(f"[udp_server] Response: {response}\n")
                        response_raw = response.encode('utf-8')
                        print_log(f"[udp_server] Response Raw: {response_raw}\n")
                        server_sock.sendto(response_raw, client_addr)
                else:
                    continue
    except KeyboardInterrupt:
        trace = traceback.format_exc()
        print('Erro: ', trace)
        open('trace.log', 'a').write(trace)
        server_sock.close()
        raise SystemExit
    except UnicodeDecodeError as e:
        trace = traceback.format_exc()
        print('Erro: ', trace)
        open('trace.log', 'a').write(trace)
        #  server_sock.close()     # For testing, we leave system running
        #  raise SystemExit        # For testing, we leave system running
    except:
        trace = traceback.format_exc()
        print('Erro: ', trace)
        open('trace.log', 'a').write(trace)
        # server_sock.close()     # For testing, we leave system running
        # raise SystemExit        # For testing, we leave system running

    server_sock.close()


if __name__ == '__main__':

    # Some prefixed configurations
    base_dir = os.path.join(os.getcwd()) + "/"
    server_port = 34567
    server_addr = '0.0.0.0'
    buffer = 2048

    if base_dir is None and len(sys.argv) == 1:
        print(f"""\n ERROR in command. The program parameters: {sys.argv[0]} base_dir\n
          or\n
          $ {sys.argv[0]} local_address  local_port base_dir\n
          The parameter 'base_dir' contains all the files and the keys\n""")
    elif len(sys.argv) > 1:
        if len(sys.argv) == 2:
            server_addr = sys.argv[1]
            # socket.getaddrinfo("example.org", 80, proto=socket.IPPROTO_TCP)
        elif len(sys.argv) == 3:
            server_addr = sys.argv[1]
            server_port = int(sys.argv[2])
        elif len(sys.argv) == 4:
            server_addr = sys.argv[1]
            server_port = int(sys.argv[2])
            base_dir = sys.argv[3]

    # Full path specification
    log_file = base_dir + log_file   # "log-for-udpserver-jwt.txt"
    log_file_conn = base_dir + log_file_conn  # 'dec7557-log-connection_and_request.txt'
    log_file_content = base_dir + log_file_content # 'dec7557-log-group_and_payload.txt'
    log_file_responses = base_dir + log_file_responses  # 'dec7557-log-group_and_responses.txt'
    log_file_sucess = base_dir + log_file_sucess  # 'dec7557-log-sucess.txt'
    log_response_pay = base_dir + log_response_pay  # "dec7557-response-payloads.txt"
    log_response_jwt = base_dir + log_response_jwt # "dec7557-response-JWT.txt"
    print_log(f"[main] log_file: {log_file}")
    print_log(f"[main] log_file_conn: {log_file_conn}")
    print_log(f"[main] log_file_content: {log_file_content}")
    print_log(f"[main] log_file_responses: {log_file_responses}")
    print_log(f"[main] log_file_sucess: {log_file_sucess}")
    print_log(f"[main] log_response_pay: {log_response_pay}")
    print_log(f"[main] log_response_jwt: {log_response_jwt}")

    read_public_keys(base_dir)

    try:
        secret_key = read_secret_key(base_dir)
        if secret_key is None:
            write_log()
    except FileExistsError:
        trace = traceback.format_exc()
        print('ERROR - exiting: ', trace)
        open('trace.log', 'a').write(trace)
        sys.exit(1)

    while True:
        udp_server(server_addr, server_port, buffer)


